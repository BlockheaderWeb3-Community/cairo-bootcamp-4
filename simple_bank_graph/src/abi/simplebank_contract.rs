// ****
// Auto-generated by cainome do not edit.
// ****

#[derive(Debug)]
pub struct simplebank<A: starknet::accounts::ConnectedAccount + Sync> {
    pub address: starknet::core::types::Felt,
    pub account: A,
    pub block_id: starknet::core::types::BlockId,
}
impl<A: starknet::accounts::ConnectedAccount + Sync> simplebank<A> {
    pub fn new(address: starknet::core::types::Felt, account: A) -> Self {
        Self {
            address,
            account,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &A::Provider {
        self.account.provider()
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(Debug)]
pub struct simplebankReader<P: starknet::providers::Provider + Sync> {
    pub address: starknet::core::types::Felt,
    pub provider: P,
    pub block_id: starknet::core::types::BlockId,
}
impl<P: starknet::providers::Provider + Sync> simplebankReader<P> {
    pub fn new(address: starknet::core::types::Felt, provider: P) -> Self {
        Self {
            address,
            provider,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &P {
        &self.provider
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct AccountClosed {
    pub closed: cainome::cairo_serde::ContractAddress,
    pub beneficiary: cainome::cairo_serde::ContractAddress,
    pub amount: u64,
}
impl cainome::cairo_serde::CairoSerde for AccountClosed {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.closed,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.beneficiary,
            );
        __size += u64::cairo_serialized_size(&__rust.amount);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.closed),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.beneficiary,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.amount));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let closed = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&closed);
        let beneficiary = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &beneficiary,
            );
        let amount = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&amount);
        Ok(AccountClosed {
            closed,
            beneficiary,
            amount,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct AccountCreated {
    pub name: starknet::core::types::Felt,
    pub address: cainome::cairo_serde::ContractAddress,
    pub balance: u64,
}
impl cainome::cairo_serde::CairoSerde for AccountCreated {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet::core::types::Felt::cairo_serialized_size(&__rust.name);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address,
            );
        __size += u64::cairo_serialized_size(&__rust.balance);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(starknet::core::types::Felt::cairo_serialize(&__rust.name));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.address),
            );
        __out.extend(u64::cairo_serialize(&__rust.balance));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let name = starknet::core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet::core::types::Felt::cairo_serialized_size(&name);
        let address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&address);
        let balance = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&balance);
        Ok(AccountCreated {
            name,
            address,
            balance,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct BankAccount {
    pub name: starknet::core::types::Felt,
    pub address: cainome::cairo_serde::ContractAddress,
    pub balance: u64,
    pub opened: bool,
}
impl cainome::cairo_serde::CairoSerde for BankAccount {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet::core::types::Felt::cairo_serialized_size(&__rust.name);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address,
            );
        __size += u64::cairo_serialized_size(&__rust.balance);
        __size += bool::cairo_serialized_size(&__rust.opened);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(starknet::core::types::Felt::cairo_serialize(&__rust.name));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.address),
            );
        __out.extend(u64::cairo_serialize(&__rust.balance));
        __out.extend(bool::cairo_serialize(&__rust.opened));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let name = starknet::core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet::core::types::Felt::cairo_serialized_size(&name);
        let address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&address);
        let balance = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&balance);
        let opened = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&opened);
        Ok(BankAccount {
            name,
            address,
            balance,
            opened,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct DepositMade {
    pub amount: u64,
    pub address: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for DepositMade {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u64::cairo_serialized_size(&__rust.amount);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u64::cairo_serialize(&__rust.amount));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.address),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let amount = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&amount);
        let address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&address);
        Ok(DepositMade { amount, address })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct TransferMade {
    pub amount: u64,
    pub from: cainome::cairo_serde::ContractAddress,
    pub to: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for TransferMade {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u64::cairo_serialized_size(&__rust.amount);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.from,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&__rust.to);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u64::cairo_serialize(&__rust.amount));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.from),
            );
        __out.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.to));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let amount = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&amount);
        let from = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&from);
        let to = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&to);
        Ok(TransferMade { amount, from, to })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct WithdrawalMade {
    pub amount: u64,
    pub address: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for WithdrawalMade {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u64::cairo_serialized_size(&__rust.amount);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u64::cairo_serialize(&__rust.amount));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.address),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let amount = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&amount);
        let address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&address);
        Ok(WithdrawalMade { amount, address })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum Event {
    AccountCreated(AccountCreated),
    DepositMade(DepositMade),
    WithdrawalMade(WithdrawalMade),
    TransferMade(TransferMade),
    AccountClosed(AccountClosed),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::AccountCreated(val) => AccountCreated::cairo_serialized_size(val) + 1,
            Event::DepositMade(val) => DepositMade::cairo_serialized_size(val) + 1,
            Event::WithdrawalMade(val) => WithdrawalMade::cairo_serialized_size(val) + 1,
            Event::TransferMade(val) => TransferMade::cairo_serialized_size(val) + 1,
            Event::AccountClosed(val) => AccountClosed::cairo_serialized_size(val) + 1,
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            Event::AccountCreated(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(AccountCreated::cairo_serialize(val));
                temp
            }
            Event::DepositMade(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(DepositMade::cairo_serialize(val));
                temp
            }
            Event::WithdrawalMade(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&2usize));
                temp.extend(WithdrawalMade::cairo_serialize(val));
                temp
            }
            Event::TransferMade(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&3usize));
                temp.extend(TransferMade::cairo_serialize(val));
                temp
            }
            Event::AccountClosed(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&4usize));
                temp.extend(AccountClosed::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    Event::AccountCreated(
                        AccountCreated::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    Event::DepositMade(
                        DepositMade::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            2usize => {
                Ok(
                    Event::WithdrawalMade(
                        WithdrawalMade::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            3usize => {
                Ok(
                    Event::TransferMade(
                        TransferMade::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            4usize => {
                Ok(
                    Event::AccountClosed(
                        AccountClosed::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("AccountCreated")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "AccountCreated"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let name = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "name",
                            "AccountCreated", e
                        ),
                    );
                }
            };
            data_offset += starknet::core::types::Felt::cairo_serialized_size(&name);
            let address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "address",
                            "AccountCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &address,
                );
            let balance = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "balance",
                            "AccountCreated", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&balance);
            return Ok(
                Event::AccountCreated(AccountCreated {
                    name,
                    address,
                    balance,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("DepositMade")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "DepositMade"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let amount = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amount",
                            "DepositMade", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&amount);
            let address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "address",
                            "DepositMade", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &address,
                );
            return Ok(Event::DepositMade(DepositMade { amount, address }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("WithdrawalMade")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "WithdrawalMade"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let amount = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amount",
                            "WithdrawalMade", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&amount);
            let address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "address",
                            "WithdrawalMade", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &address,
                );
            return Ok(Event::WithdrawalMade(WithdrawalMade { amount, address }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("TransferMade")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "TransferMade"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let amount = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amount",
                            "TransferMade", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&amount);
            let from = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "from",
                            "TransferMade", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&from);
            let to = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "to",
                            "TransferMade", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&to);
            return Ok(Event::TransferMade(TransferMade { amount, from, to }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("AccountClosed")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "AccountClosed"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let closed = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "closed",
                            "AccountClosed", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&closed);
            let beneficiary = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "beneficiary",
                            "AccountClosed", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &beneficiary,
                );
            let amount = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amount",
                            "AccountClosed", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&amount);
            return Ok(
                Event::AccountClosed(AccountClosed {
                    closed,
                    beneficiary,
                    amount,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
impl<A: starknet::accounts::ConnectedAccount + Sync> simplebank<A> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_account_details(
        &self,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, BankAccount> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_account_details"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_balance(&self) -> cainome::cairo_serde::call::FCall<A::Provider, u64> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_balance"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn close_account_getcall(
        &self,
        beneficiary: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(beneficiary));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("close_account"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn close_account(
        &self,
        beneficiary: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(beneficiary));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("close_account"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn deposit_getcall(&self, amount: &u64) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u64::cairo_serialize(amount));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("deposit"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn deposit(&self, amount: &u64) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u64::cairo_serialize(amount));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("deposit"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn open_account_getcall(
        &self,
        name: &starknet::core::types::Felt,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(name));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("open_account"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn open_account(
        &self,
        name: &starknet::core::types::Felt,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(name));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("open_account"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_getcall(
        &self,
        amount: &u64,
        recipient: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u64::cairo_serialize(amount));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(recipient));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer(
        &self,
        amount: &u64,
        recipient: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u64::cairo_serialize(amount));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(recipient));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn withdraw_getcall(&self, amount: &u64) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u64::cairo_serialize(amount));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("withdraw"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn withdraw(&self, amount: &u64) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u64::cairo_serialize(amount));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("withdraw"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
}
impl<P: starknet::providers::Provider + Sync> simplebankReader<P> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_account_details(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, BankAccount> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_account_details"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_balance(&self) -> cainome::cairo_serde::call::FCall<P, u64> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_balance"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
}
